# 1.String、StringBuffer和StringBuilder

**String**是字符串常量，适用与少量的字符串操作，而**StringBuffer**和**StringBuilder**是字符串变量，**StringBuilder**适用于单线程下大量的字符串操作，**StringBuffer**则适用于多线程下大量的字符串操作，所以**StringBuilder**是线程不安全的，**StringBuffer**是线程安全的，所以性能上**StringBuilder**是略优于**StringBuffer**的。

**String**字符串常量一旦声明则不可改变（字符序列不可改变直到销毁，因为是不可变的所以**String**也是线程安全的），而字符串对象可以改变，但改变的是其内存的地址指向。其实简单理解就是前后者名字一样但实际是两个完全不同的实例对象，引用指向最新生成的实例。

> **扩展：String a = "xx" 和 new String("xx")**

常量池：Jvm在加载Class文件后存放在方法区的各种字面量和符号引用

**String a = "xx"** 是 查找String Pool中是否存在"xx"这个对象，如果不存在，则在String Pool中创建一个"xx"对象，然后将String Pool中的这个"xx"对象地址返回来，赋给引用变量a，如果存在，则直接将String Pool中的"xx"对象地址返回来，赋给引用变量a。这样，a的地址就指向了String Pool中的"xx"

**String a = new String("xx")** 是首先在String Pool中查找有没有"xx"这个字符串对象，如果有，则不在String Pool中再去创建"xx"这个对象，直接在堆(heap)中创建一个"xx"字符串对象，然后将堆中这个"xx"对象的地址返回来，赋给a引用；如果Spring Pool中没有"xx"这个对象，首先是在Spring Pool中创建一个"xx"对象，然后再在堆中创建一个"xx"对象，然后将堆中的这个"xx"对象的地址返回来，赋给a引用。这样，a的地址就指向了堆中的"xx"。

# **2.反射机制**

> 反射是什么？

Java反射机制是指在**运行状态中**对于任何一个类，都能够知道这个类的所有属性和方法；对于任何一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java的反射机制。

反射提供的功能：（要想解剖一个类,必须先要获取到该类的字节码文件对象（class）。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象）

》在运行时判断任意一个对象所属的类

》在运行时构造任意一个类的对象

》在运行时判断任意一个类所具有的成员变量和方法

》在运行时调用任意一个对象的方法

> **Class对象**

Class对象是将class文件读入内存，并为之创建一个Class对象。当我们new一个对象时，Jvm都会去本地磁盘中找这个对象的class文件加载到Jvm内存中，同时产生class对象，这个class对象是Jvm自动创建的一个class对象，必须有且一个类只产生一个class对象。反射的本质理解就是得到class对象后反向获取new对象的各种信息。

> **Class类**

Class类是代表一个类，名字就是Class，是Java反射机制的起源和入口，用于获取与类相关的各种信息， 提供了获取类信息的相关方法。Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象（包括基本数据类型），Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。

> 反射的三种形式

1.**通过通过Class.forName("全类名")**

2.**类名.class**

3.**对象.getClass()**

> 示例

根据反射入口对象获取类的各种信息

getMethods()获取此类的所有public方法（父类的，实现接口的，自己的）

```Java
Class<?> perClazz = null;
		try {
			person = Class.forName("com.Person");
		} catch (ClassNotFoundException e) {
			
			e.printStackTrace();
		}
		Method[] methods = person.getMethods();
                //遍历所有方法
		for (Method method : methods) {
			System.out.println(method);
		}
	}
```

通过反射获取对象的实例，并操作对象

**newInstance()** 是创建实例

**getMethod(methodName)** 根据方法名称获取方法

**invoke(pe) **执行pe对象的methodName方法

```java
Class<?> perClazz = null;
		try {
			person = Class.forName("com.Person");
		} catch (ClassNotFoundException e) {
			
			e.printStackTrace();
		}
		Method[] methods = person.getMethods();
        Person pe = (Person)person.newInstance();
		//获取、执行方法
		Method method = person.getMethod(methodName);
		method.invoke(pe);
	}
```

> **反射的优缺点**

反射提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创造和控制任何类的的对象，无需提前硬编码。缺点就是性能问题，使用反射基本上是一种提前解释和声明的做法，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求很高的系统框架上，比如Spring等。

# **3.equals和==**

**"=="**是运算符，如果比较的对象是基本数据类型，则比较的是其**存储值**是否相等；如果比较的是引用数据类型，则比较的是所指**对象的地址**是否相等。

**equals**是Object的方法，也就是说只要继承了Object，都可以equals。equals不能用于比较基本数据类型，如果没有重写equals，则相当与"=="，比较的是变量所指向的对象的地址值。【一般情况下，类会重写equals方法用来比较两个对象的内容是否相等。比如**String类中的equals()重写了，比较的是对象的内容是否相等**】

> **注意**

StringBuilder和StringBuffer是没有重写equals方法的。也就是说比较的是对象的地址值是否相等。

# 4.事务

> **数据库事务**

事务是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行。

**事务的四大特性**

1.原子性

事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。

2.一致性

事务执行前后的数据必须是完整的，从一个一致性的状态变到另一个一致性的状态

3.隔离性

一个事务的执行不能被其他事务所干扰和影响。即一个事务内部的操作及使用的数据对其它事务是隔离的，并发执行的各个事务之间不能互相干扰。

4.持续性

事务一旦提交，数据是永久写入数据库的。

**MySql事务隔离级别**

1、读未提交（Read Uncommited），该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取

2、授权读取也称为已提交读（Read Commited），授权读取只允许获取已经提交的数据。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。

3、可重复读（Repeatable Read)

就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；

4、串行化

是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。

**读未提交**的隔离级别会可能造成脏读，**已提交读**的隔离级别可能会出现不可重复读，**可重复读**的隔离级别也许会出现幻读，**串行化**最高隔离级别不会出现前三种情况。【隔离级别越低出现的特殊问题就越多，前者包含后者，读未提交也可能会出现不可重复读和幻读】

> **Spring事务**

Spring事务本质是对数据库事务的支持，如果数据库不支持则Spring事务也不会生效的。

**Spring事务的传播**

事务传播行为是指一个事务方法A被另一个事务方法B调用时，这个事务A应该如何处理。
Spring事务注解**@Transactional(propagation = Propagation.REQUIRED)**，PROPAGATION_REQUIRED默认的常量，支持当前事务，如果没有则新建一个事务。

| 常量名称                  | 解释                                                         |
| :------------------------ | :----------------------------------------------------------- |
| PROPAGATION_REQUIRED      | 默认的事务传播，支持当前事务，如果没有事务就新建一个         |
| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务的方式执行         |
| PROPAGATION_MANDATORY     | 支持当前事务，如果当前没有事务就抛出异常                     |
| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后， 不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获， 也可以不处理回滚操作。使用JtaTransactionManager作为事务管理器 |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。使用JtaTransactionManager作为事务管理器 |
| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常               |
| PROPAGATION_NESTED        | 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。 |

# **5.索引**

**索引是什么**

索引是帮助数据库高效获取数据的**数据结构**

索引的文件存储形式与存储引擎相关

**索引分类**

主键索引

主键索引也被称为聚簇索引，不允许有空值，主键索引的数据结构B+树的叶子节点上存储的是数据块，而且是有序的，叶子节点是连在一起的。

唯一索引（**UNIQUE**）

```MySQL
# 创建单列唯一索引

alter table sc add unique (name);
# 创建多列唯一索引

alter table sc add unique key `name_score` (`name`,`score`);
#删除
alter table sc drop index name;
```

唯一索引可以是单列也可以是多列，索引列的值必须唯一，但允许有空值，默认创建唯一性的非聚簇索引。

普通索引（**INDEX**）

最基本的索引，没有限制。

全文索引（**FULLTEXT** ）

```MySQL
#创建
create fulltext index content_tag_fulltext
    on fulltext_table(content,tag);

#删除
drop index content_tag_fulltext
    on fulltext_table;
    
#语法
SELECT * FROM `student` WHERE MATCH(`name`) AGAINST('聪')
 
-- 当查询多列数据时：
-- 建议在此多列数据上创建一个联合的全文索引，否则使用不了索引的。
 
SELECT * FROM `student` WHERE MATCH(`name`,`address`) AGAINST('聪 而是东')
```

全文索引有一个最小搜索长度（字段内容长度）和最大搜索长度的限制，InnoDB默认区间是[3,84]。 match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，无法使用全文索引，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，请单独为该列创建全文索引。

组合索引

```mysql
MariaDB [test]> alter table t add index c1234(c1,c2,c3,c4);
```

组合索引遵循“最左匹配原则”，当【条件中有or、在索引上计算、数据类型的隐形转换、使用函数、like查询用%开头、范围查询、is null/is not null】会导致索引失效

> 回表

在主键索引的基础上，添加另一个列A作为索引，A索引的存储中value为主键的值，如果要通过A字段查其他字段的值，首先是通过A的索引查取到主键值，然后再通过主键索引查询其他字段的值，这个过程就是回表。

> 索引覆盖

添加一个非主键索引A，正好要查询的是通过字段A查询主键，则只需要根据A索引查询主键就可以了，无需主键索引的查询。这种被称为索引覆盖。

> 最左匹配原则

最左匹配原则是在组合索引的基础上，按照从左到右的原则匹配，例如添加组合索引A(name,age),查询的时候条件是name或者是name和age（age和name的顺序由优化器处理，所以name和age顺序无要求，但是只有一个age是不可以的，因为不能跳跃，违背了最左匹配原则）都是最左匹配原则实现的。

> 索引下推

索引下推也是在组合索引的基础上，MySQL5.7以后包含的功能。从存储引擎拉取数据的时候直接按照name和age做判断，将符合的结果返回到MySQL的Server。索引下推是把本应该在 server 层进行筛选的条件，下推到存储引擎层来进行筛选判断，这样能有效减少回表。

> 聚簇索引和非聚簇索引

聚簇索引就是主键创建的索引，非聚簇索引就是除了主键以外的索引，也就二级索引。二者最大的区别就是数据结构上数据存储的形式不一样，聚簇索引在叶子上存放的整行数据，非聚簇索引在叶子节点上存储的是主键。非聚簇索引存储的数据和索引是不在一个文件存放的，而聚簇是在一个文件。

# **6.MySQL锁**

MySQL的锁可以大致分为**全局锁**、**表级锁**和**行锁**三类

> **全局锁**

全局锁就是对整个数据库实例加锁。MySQl提供了一个加全局读锁的方法，命令是**Flush tables with read lock**。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的一下语句会被阻塞：数据的增删改查、数据定义语句和更新事务的提交语句。

如全库只读可以使用set global readonly=true的方式

> **表级锁**

MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（**MDL**）

表锁语法：lock tables  ... read/write。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。不仅限制别的线程读写外也限定了本线程的一些操作。

如果在某个线程A中执行lock tables t1 read,t2 write 这个语句，则其他线程对t1 和t2 的语句会被阻塞。同时，线程A在执行unlock tables 之前，也只能执行读t1、读写t2的操作。

另一种表级的锁是MDL。MDL不需要显示使用，在访问一个表的时候会被自动加上。MDL的作用是保证读写的正确性。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

**读锁之间不互斥，因此可以有多个线程同时对一张表增删改查**

**读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行**

**事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放**

> **行锁**

MySQL的行锁是在引擎层由各个引擎自己实现的，但不是所有的引擎都支持行锁，比如MyISAM引擎是不持支行锁的

行锁就是针对数据表行记录的锁。不同事务更新同一行数据时，后者要等前者操作完成提交事务后才能进行更新

***如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**

**死锁**

在并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无线等待的状态，称为死锁。出现死锁后有以下两种策略：

**1**.一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置

**2**.另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑

# **7.乐观锁和悲观锁**

> 乐观锁

乐观的认为每次拿数据的时候别人都不会修改。所以不会上锁，但是如果想要更新数据，则会在更新前检查在读取至更新这段时间内别人有没有修改过这个数据。如果修改过则重新读取，再次尝试更新，循环上述步骤直到更新成功，乐观锁适用于多读的应用，这样可以提高吞吐量。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本（version）或者是时间戳来实现，不过使用版本记录是最常用的。

> 悲观锁

悲观锁就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人在拿数据的时候就会被挡住，直到悲观锁被释放，悲观锁中的共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。在效率方面，处理加锁的机制会产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，如果已经锁定了一个线程A，其他线程就必须等待该线程A处理完才可以。数据库中的行锁、表锁、读锁（共享锁）、写锁（排他锁）、以及syncronized实现的锁均为悲观锁。采用“先取锁再访问”的保守策略。

# **8.重写equals方法、重写hashCode**

重写equals方法就必须要重写hashCode，为了维护hashCode的常规协定。

重写equals按照自己需要的条件规定和目标对象相等的条件，重写hashCode确保hash码值也是按照equals的规定去计算的，因为通常在一些HashMap、HashSet等集合中，判断该对象是否存在是按照hashCode去判定的（**实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址**）。如果不重写，会造成一个问题就是原本是判定为相同对象的，但是在集合使用的时候是不相等的。

> 注意

同一个对象hashCode一定相等

拥有相等hashCode的对象不一定是同一个对象。（进一步确认就调用equals方法）

# 9.on与where的区别

联表查询的时候使用on会保留主表里为假的数据，不会过滤主表的null，是联表的时候直接返回符合条件的结果。where是根据返回的中间表过滤数据。

例如：放where过滤

![image-20221104170539445](C:\Users\陈和斌\AppData\Roaming\Typora\typora-user-images\image-20221104170539445.png)

放在on条件的时候

![image-20221104170646478](C:\Users\陈和斌\AppData\Roaming\Typora\typora-user-images\image-20221104170646478.png)
